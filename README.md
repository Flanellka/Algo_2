# mid1 Подсчет значений в массиве

### Описание

Предположим, у вас есть обширная база данных, в которой хранится информация о **ключевых точках**, полученных при распознавании лиц (например, координаты особых меток на изображении лица, используемые для идентификации сотрудника). Эта база постоянно растет, а операции поиска в ней выполняются очень часто.

Чтобы ускорить доступ к нужным данным, необходимо спроектировать **составной индекс** на базе **бинарного дерева** (или другой подходящей деревоподобной структуры), где условие разбиения и хранения записей задаётся выбранным вами принципом.

В рамках задания требуется:

1. Разработать структуру данных (бинарное дерево) для хранения записей.
2. Реализовать в ней:
   - Парсинг входных данных (построение дерева по обходу).
   - Подсчет основных характеристик дерева, например:
     - Общее количество узлов
     - Минимальный и максимальный ID
     - Высота дерева
     - Количество листьев
   - Проверку корректности структуры (например, что дерево удовлетворяет свойству BST: все узлы слева меньше корня, справа — больше).
3. Организовать тестирование (в том числе автогенерацию тестов и их запуск).

### Ограничения
- Размер входных данных может достигать высоких значений, поэтому важно учитывать эффективность.
- Формат хранения записей (ID, координаты X и Y) выбирается по вашему усмотрению. В данном демо они представлены в **прямом (preorder) обходе**, где `#` обозначает пустое поддерево.

#### Пример входных данных

10 12.3 45.6 5 3.1 4.4 # # 8 0.0 1.0 # # # 20 50.1 50.2 # #

*(Этот пример означает дерево, где корень имеет `id=10, x=12.3, y=45.6`, затем левый узел с `id=5, x=3.1, y=4.4` и т.д. Пустые `#` обозначают отсутствие поддерева.)*

#### Пример выходных данных

Общее количество узлов: 4 Минимальный ID: 5 Максимальный ID: 20 Высота дерева: 3 Количество листьев: 2
